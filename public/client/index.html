<!DOCTYPE html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="/public/dist/phaser.js"></script>
<script type="text/javascript" src="/public/dist/pathfinding-browser.min.js"></script>
  <style type="text/css">
      body {
          margin: 0;
          background-color: #333;
          font-family: pixelFont;
      }
      #game {
        position: absolute;
        top: 150px;
        left: 0;
      }

      #output {
        position: absolute;
        top: 150px;
        left: 800px;
        color: white;
      }

      #hud {
        position: absolute;
        top: 700px;
        left: 0;
      }

      #hud-output {
        color: #FFF;
        position: absolute;
        top: 45px;
        left: 10px;
      }

      #weapons-hud {
        position: absolute;
        top: 550px;
        left: 800px;
      }

      #weapons-output {
        position: absolute;
        top: 20px;
        left: 10px;
        color: white;
      }

      #endturn {
        display: none;
      }


      #stat-output {
        color: #FFF;
        position: absolute;
        top: 45px;
        left: 250px;
      }

      @font-face {
          font-family: pixelFont;
          src: url(/public/client/assets/VCR_OSD_MONO_1.001.ttf);
      }
  </style>
<script>
window.addEventListener("load", function(evt) {

    var output = document.getElementById("output");
    var input = document.getElementById("input");
    var ws;

    var print = function(message, id) {
        var d = document.createElement("div");
        d.innerHTML = message;
        if (id) {
          var o = document.getElementById(id);
          o.appendChild(d);
        } else {
          output.appendChild(d);
        }
    };

    var clr = function(id) {
      if (id) {
        var o = document.getElementById(id);
        o.innerHTML = '';
      }
      else output.innerHTML = '';
    };

    document.getElementById("open").onclick = function(evt) {
        if (ws) {
            return false;
        }
        ws = new WebSocket("{{.}}");
        ws.onopen = function(evt) {
            print("OPEN");
            createGame();
        }
        ws.onclose = function(evt) {
            print("CLOSE");
            ws = null;
        }
        ws.onmessage = function(evt) {
            print("RESPONSE: " + evt.data);
            console.log(JSON.parse(evt.data));
            var message = JSON.parse(evt.data);
            switch (message.MessageType) {
              case 'team':
                myTeam = parseInt(message.Message)
                if (myTeam == 0) myColor = "red";
                else myColor = "blue";
                console.log(message);
                console.log('got team message, on team ' + myTeam)
                break;
              case 'announce':
                //alert(message.Message);
                break;
              case 'map_data':
                clearMap();
                inGame = true;
                loadMap(message);
                break;
              case 'game_start_army_data':
                //window.game.stage.disableVisibilityChange = true;
                var m = JSON.parse(message.Message);
                console.log(m);
                loadUnits(m);
                cursor = game.add.sprite(0, 0, 'tile_outline_' + myColor);
                break;
              case 'game_move':
                var m = JSON.parse(message.Message);
                var u = unitHash[m.uid];
                tileArray[u.x][u.y].unit = '';
                u.x = m.moves[m.moves.length - 1][0];
                u.y = m.moves[m.moves.length - 1][1];
                tileArray[u.x][u.y].unit = u.uid;
                //u.sprite.x = u.x * TILESIZE;
                //u.sprite.y = u.y * TILESIZE;
                var timer = setInterval(function(){
                  if (!activeMove.path && !activeMove.unit){
                    activeMove.path = m.moves;
                    activeMove.unit = u;
                    clearTimeout(timer);
                  }
                }, 100)
                u.actionCount = u.actionCount - 1;
                if (u.actionCount <= 0) {
                  u.combatCount = 0;
                  u.sprite.tint = 0x333333;
                }
                if (selectedUnit == u) {
                  cursor.x = u.x * TILESIZE;
                  cursor.y = u.y * TILESIZE;
                  u.showInfo();
                }
                updateMatrix();
                break;
              case 'game_use_weapon':
                var m = JSON.parse(message.Message);
                var u = unitHash[m.uid];
                var t = unitHash[m.target];
                var damage = m.damage;
                u.actionCount = u.actionCount - 1;
                u.combatCount = u.combatCount - 1;
                if (u.actionCount <= 0) {
                  u.combatCount = 0;
                  u.sprite.tint = 0x333333;
                }
                if (damage > 0) {
                  t.attributes.Hps = t.attributes.Hps - damage;
                }
                selectedUnit.showInfo();
                break;
              case 'game_turn':
                currentTurn = parseInt(message.Message);
                clr();
                var btn = document.getElementById('endturn');
                if (myTurn()) {
                  btn.style.display = 'block'
                  print("It's your turn!");
                } else {
                  print("Your opponents turn has begun");
                  btn.style.display = 'none'
                }
                resetActions();
                updateMatrix();
                break;
              default:
                console.log("Message " + message + " recieved with no handler!")
            }
        }
        ws.onerror = function(evt) {
            print("ERROR: " + evt.data);
        }
        return false;
    };

    document.getElementById("send").onclick = function(evt) {
        if (!ws) {
            return false;
        }
        switch (input.value) {
          case 'new':
            newMap();
            break;
          default:
            break;
        }
        print("SEND: " + input.value);
        //ws.send(input.value);
        return false;
    };

    document.getElementById('endturn').onclick = function(evt) {
      ws.send('end_turn');
    }

    document.getElementById("close").onclick = function(evt) {
        if (!ws) {
            return false;
        }
        ws.close();
        return false;
    };

    function createGame(){
      var game = new Phaser.Game(800, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update });
      //message = JSON.parse(message.Message);
      //game.currentMapData = message.Map;
      window.game = game;
    }

    /* PHASER GAME CLIENT BEGINS HEREEEEEEE */


    var tileArray = [[]];
    var unitHash = {};
    var selectedTile = 1;
    var TILESIZE = 48;
    var key1;
    var key2;
    var key3;
    var key4;
    var keyQ;
    var keyE;
    var mouseDown = false;
    var inGame = false;
    var myTeam = null;
    var currentTurn = null;
    var myColor = null;
    var cursor = null;
    var selectedUnit = null;
    var mapMatrix = null;
    var activeMove = {};
    var weaponsUi = document.getElementById("weapons");

    function myTurn() {
      return currentTurn === myTeam;
    }

    function updateMatrix() {
      var w = tileArray.length;
      var h = tileArray[0].length;
      var matrix = new PF.Grid(w, h);
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
          if (tileArray[i][k].walkable && !tileArray[i][k].unit) {
            matrix.setWalkableAt(i, k, true);
          } else {
            matrix.setWalkableAt(i, k, false);
          }
        }
      }
      mapMatrix = matrix;
    }

    function preload() {
      //
      game.load.image('tile_outline', '/public/client/assets/sprites/tiles/tile_outline.png');
      game.load.image('tile_outline_red', 'public/client/assets/sprites/tiles/tile_outline_red.png');
      game.load.image('tile_outline_blue', 'public/client/assets/sprites/tiles/tile_outline_blue.png');
      game.load.image('grass1', 'public/client/assets/sprites/tiles/grass1.png');
      game.load.image('mountain1', 'public/client/assets/sprites/tiles/mountain1.png');
      game.load.image('water1', 'public/client/assets/sprites/tiles/water1.png');
      game.load.image('castle1', 'public/client/assets/sprites/tiles/castle1.png');
      game.load.image('blank', 'public/client/assets/sprites/tiles/blank.png');
      game.load.image('rock1', 'public/client/assets/sprites/tiles/rock1.png');
      game.load.image('archerguy_red', 'public/client/assets/sprites/units/archerguy_red.png');
      game.load.image('archerguy_blue', 'public/client/assets/sprites/units/archerguy_blue.png');

      game.load.image('river1', 'public/client/assets/sprites/tiles/river1.png');
      game.load.image('river2', 'public/client/assets/sprites/tiles/river2.png');
      game.load.image('river3', 'public/client/assets/sprites/tiles/river3.png');
      game.load.image('river4', 'public/client/assets/sprites/tiles/river4.png');
      game.load.image('river5', 'public/client/assets/sprites/tiles/river5.png');
      game.load.image('river6', 'public/client/assets/sprites/tiles/river6.png');
      game.load.image('river7', 'public/client/assets/sprites/tiles/river7.png');
      game.load.image('river8', 'public/client/assets/sprites/tiles/river8.png');
      game.load.image('river9', 'public/client/assets/sprites/tiles/river9.png');
      game.load.image('river10', 'public/client/assets/sprites/tiles/river10.png');
      game.load.image('river11', 'public/client/assets/sprites/tiles/river11.png');
      game.load.image('river12', 'public/client/assets/sprites/tiles/river12.png');
      game.load.image('river13', 'public/client/assets/sprites/tiles/river13.png');

    }

    function resetActions() {
      Object.keys(unitHash).forEach(function (key) {
          var unit = unitHash[key]
          unit.actionCount = 2;
          unit.combatCount = 1;
          // iteration code
          unit.sprite.tint = 0xffffff;
      })
    }

    function calculateWater() {
      var w = tileArray.length;
      var h = tileArray[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
            if (tileArray[i][k].tileType == "river"){
              var left = false;
              var right = false;
              var up = false;
              var down = false;
              if (tileArray[i+1] && tileArray[i+1][k].tileType == "river") right = true;
              if (tileArray[i-1] && tileArray[i-1][k].tileType == "river") left = true;
              if (tileArray[i][k+1] && tileArray[i][k+1].tileType == "river") down = true;
              if (tileArray[i][k-1] && tileArray[i][k-1].tileType == "river") up = true;
              var key;
              if (left && right && down && up) key = 5;
              else if (left && down && right) key = 10;
              else if (left && up && right) key = 11;
              else if (left && up && down) key = 12;
              else if (up && down & right) key = 13;
              else if (right && down) key = 1;
              else if (left && right) key = 2;
              else if (left && down) key = 3;
              else if (up && down) key = 6;
              else if (up && left) key = 9;
              else if (right && up) key = 7;
              else if (up) key = 6;
              else if (down) key = 6;
              else key = 2;
              console.log(key);
              //debugger;
              tileArray[i][k].updateTexture('river' + key, 2);
            }
        }
      }
    }

    var Unit = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      if (params.team == 0) this.color = "red";
      else this.color = "blue";
      this.team = params.team;
      this.key = key + "_" + this.color;
      this.sprite = game.add.sprite(x, y, this.key);
      this.displayName = params.DisplayName;
      this.sprite.inputEnabled = true;
      this.owner = params.Owner || 0;
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;
      this.actionCount = 2;
      this.combatCount = 1;
      this.leader = params.leader || false;
      this.uid = params.Uid;
      this.attributes = params.Attributes;

      tileArray[this.x][this.y].unit = this.uid;

      var self = this;

      this.sprite.events.onInputDown.add(function(){
        self.showInfo();
      });

     self.showInfo = function(){
       clr();
       clr('hud-output');
       clr('stat-output');
       clr('weapons-output');
       if (myTeam == self.team)
         print("friendly " + self.displayName, 'hud-output');
       else
         print("enemy " + self.displayName, 'hud-output');
       if (self.leader) print("LEADER")
       print("remaining actions: " + self.actionCount, 'hud-output');
       print("remaining attacks: " + self.combatCount, 'hud-output');
       print("team: " + self.color, 'hud-output');
       print("hitpoints: " + self.attributes.Hps, 'stat-output');
       print("speed: " + self.attributes.Hps, 'stat-output');
       print("defense: " + self.attributes.Def, 'stat-output');
       print("armor: " + self.attributes.Amr, 'stat-output');

       print("weapons:", "weapons-output");
       print("", "weapons-output");
       self.attributes.Weapons.forEach(function(w){
         print("------------", "weapons-output");
         print(w.DisplayName, "weapons-output");
         print("Durability: " + w.UsesRemaining, "weapons-output");
         print("ATK: " + w.Atk, "weapons-output");
         print("RNG: " + w.Rng, "weapons-output");
         print("DMG: " + w.Dmg, "weapons-output");
         print("------------", "weapons-output");
       })

       if (myTurn() && myTeam != self.team && selectedUnit && selectedUnit.team === myTeam && selectedUnit.combatCount > 0) {
         selectedUnit.attributes.Weapons.forEach(function(w){
           print("ATTACK with:", "weapons-output");
           print("------------", "weapons-output");
           print(w.DisplayName), "weapons-output";
           print("Durability: " + w.UsesRemaining, "weapons-output");
           print("ATK: " + w.Atk, "weapons-output");
           print("RNG: " + w.Rng, "weapons-output");
           print("DMG: " + w.Dmg, "weapons-output");
           print("hit on: 1d20+" + w.Atk + " > " + self.attributes.Def, "weapons-output");
           var useBtn = '<button id="' + w.Uid + '">Use</button>';
           print(useBtn, "weapons-output");
           document.getElementById(w.Uid).addEventListener("click", function(){
             var ret = {};
             ret.messageType = "game_use_weapon";
             ret.message = {};
             ret.message.uid = selectedUnit.uid;
             ret.message.target = self.uid;
             ret.message.weapon = w.Uid;
             ret.message = JSON.stringify(ret.message)
             ws.send(JSON.stringify(ret));
             console.log("attacked with weapon " + w.Uid);
           });
           print("------------", "weapons-output");
         })
       }
     }

      this.sprite.events.onInputDown.add(function(){
        if (selectedUnit && selectedUnit.team !== self.team && selectedUnit.combatCount > 0 && selectedUnit.team == myTeam) {

        } else {
          cursor.x = self.x * TILESIZE;
          cursor.y = self.y * TILESIZE;
          selectedUnit = self;
        }
      })

      self.move = function(x, y) {
        var grid = mapMatrix.clone();
        var finder = new PF.AStarFinder();
        var path = finder.findPath(self.x, self.y, x, y, grid);
        if (path.length === 0 || path.length - 1 > self.attributes.Spd) {
          return;
        }
        var ret = {};
        ret.messageType = "game_move";
        ret.message = {};
        ret.message.uid = self.uid;
        ret.message.moves = path;
        ret.message = JSON.stringify(ret.message)
        ws.send(JSON.stringify(ret));
        updateMatrix();
      }

    }

    var loadUnits = function(ary){
      for (var i = 0; i < ary.length; i++){
        for (var k = 0; k < ary[i].Squads.length; k++){
          for (var l = 0; l < ary[i].Squads[k].Grunts.length; l++) {
            var u = ary[i].Squads[k].Grunts[l];
            u.team = i;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, 'archerguy', u);
          }
          if (ary[i].Squads[k].Leader) {
            var u = ary[i].Squads[k].Leader;
            u.team = i;
            u.leader = true;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, 'archerguy', u);
          }
        }
      }
    }

    var MapTile = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      this.key = params.Key || key;
      this.sprite = game.add.sprite(x, y, this.key);
      this.overlayKey = params.OverlayKey || 'blank';

      if (inGame && this.overlayKey != 'tile_outline_red' && this.overlayKey != 'tile_outline_blue'){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      } else if (!inGame){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      }
      this.sprite.inputEnabled = true;
      this.walkable = params.Walkable || true;
      this.spawn = params.Spawn || false;
      this.spawnTeam = params.SpawnTeam || 0;
      this.tileType = params.TileType || 'grass';
      this.castle = params.Castle || false;
      this.capturable = params.Capturable || false;
      this.owner = params.Owner || 0;
      if (params.Unit) {
        this.unit = params.Unit.Uid;
      }
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;

      var self = this;

      var updateTexture = function(key, layer){
        switch (layer) {
          case 2:
            self.overlay.loadTexture(key);
            self.overlayKey = key;
            break;
          default:
            self.sprite.loadTexture(key);
            self.key = key;
            break;
        }

      }

      this.updateTexture = updateTexture;

      this.sprite.events.onInputDown.add(function(){
        if (inGame && selectedUnit && selectedUnit.team == myTeam && myTurn()) {
          selectedUnit.move(self.x, self.y);
        }
      })

      this.sprite.events.onInputDown.add(function(){
        if (!inGame) {
          switch (selectedTile) {
            case 1:
              updateTexture('grass1');
              self.tileType = 'grass';
              self.walkable = true;
              break;
            case 2:
              updateTexture('grass1');
              self.tileType = "river";
              self.walkable = false;
              calculateWater()
              break;
            case 3:
              updateTexture('mountain1', 2);
              self.walkable = true;
              self.tileType = 'mountain'
              break;
            case 4:
              updateTexture('blank', 2);
              self.castle = false;
              self.capturable = false;
              break;
            case 5:
              updateTexture('tile_outline_red', 2);
              self.spawnTeam = 0;
              self.spawn = true;
              break;
            case 6:
              updateTexture('tile_outline_blue', 2);
              self.spawnTeam = 1;
              self.spawn = true;
              break;
            default:
              break;
          }
        }
      }, this);
    }


    var updateSelectedTile = function(newVal){
      console.log(newVal.event.code)

      switch (newVal.event.code) {
        case 'Digit1':
          selectedTile = 1;
          break;
        case 'Digit2':
          selectedTile = 2;
          break;
        case 'Digit3':
          selectedTile = 3;
          break;
        case 'Digit4':
          selectedTile = 4;
          break;
        case 'KeyQ':
          if (selectedTile == 5) selectedTile = 6;
          else if (selectedTile == 6) selectedTile = 5;
          else selectedTile = 5;
          break;
        default:
          selectedTile = 1;
      }

      print(selectedTile);

    }

    function createMapArray(w, h){
      var tilesArray = new Array(w);
      for (var i = 0; i < w; i++) {
        tilesArray[i] = new Array(h);
        for (var k = 0; k < h; k++) {
          var key;
          if (k % 2 == 0) key = 'grass1';
          else key = 'grass1';
          tilesArray[i][k] = new MapTile(i * TILESIZE, k * TILESIZE, key);
        }
      }
      return tilesArray;
    }

    function clearMap() {
      //debugger;
      var w = tileArray.length;
      var h = tileArray[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
          if (tileArray[i][k]) {
            tileArray[i][k].sprite.destroy();
            if (tileArray[i][k].overlay) tileArray[i][k].overlay.destroy();
          }
        }
      }
      tileArray = [[]];
    }

    function loadMap(mapAry){
      mapAry = JSON.parse(mapAry.Message).Map;
      var w = mapAry.length;
      var h = mapAry[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
          t = mapAry[i][k];
          mapAry[i][k] = new MapTile(0, 0, '', t);
        }
      }
      tileArray = mapAry;
      //debugger;
    }

    function newMap() {
      clearMap();
      tileArray = createMapArray(26, 14);
    }

    function create() {
      //tileArray = createMapArray(30, 25);
      key1 = game.input.keyboard.addKey(Phaser.Keyboard.ONE);
      key1.onDown.add(updateSelectedTile, this);
      key2 = game.input.keyboard.addKey(Phaser.Keyboard.TWO);
      key2.onDown.add(updateSelectedTile, this);
      key3 = game.input.keyboard.addKey(Phaser.Keyboard.THREE);
      key3.onDown.add(updateSelectedTile, this);
      key4 = game.input.keyboard.addKey(Phaser.Keyboard.FOUR);
      key4.onDown.add(updateSelectedTile, this);

      keyE = game.input.keyboard.addKey(Phaser.Keyboard.E);
      keyE.onDown.add(exportMap, this);

      keyQ = game.input.keyboard.addKey(Phaser.Keyboard.Q);
      keyQ.onDown.add(updateSelectedTile, this);

      game.world.scale.set(1);
      game.camera.bounds = undefined;
      game.stage.disableVisibilityChange = true;
    }

    function exportMap(){
      var ret = {};
      ret.message = {};
      ret.message.map = tileArray;
      for (var i = 0; i < ret.message.map.length; i++) {
        for (var k = 0; k < ret.message.map[1].length; k++) {
          var tileJson = {};
          var tileObj = ret.message.map[i][k];
          tileJson.key = tileObj.key;
          tileJson.overlayKey = tileObj.overlayKey;
          tileJson.walkable = tileObj.walkable;
          tileJson.spawn = tileObj.spawn;
          tileJson.spawnTeam = tileObj.spawnTeam;
          tileJson.tileType = tileObj.tileType;
          tileJson.castle = tileObj.castle;
          tileJson.capturable = tileObj.capturable;
          tileJson.x = tileObj.x;
          tileJson.y = tileObj.y;
          print(tileJson.x + " " + tileJson.y)
          ret.message.map[i][k] = tileJson;
        }
      }
      //console.log(ret);
      ret.message = JSON.stringify(ret.message);
      ret.messageType = "map_export_data";
      ws.send(JSON.stringify(ret));
    }

    function update() {
      if (activeMove.unit && activeMove.path) {
        if (activeMove.currentDest) {
          if (activeMove.unit.sprite.x < (activeMove.currentDest[0] * TILESIZE)) {
            activeMove.unit.sprite.x += 3;
          }
          if (activeMove.unit.sprite.x > (activeMove.currentDest[0] * TILESIZE)) {
            activeMove.unit.sprite.x -= 3;
          }

          if (activeMove.unit.sprite.y < (activeMove.currentDest[1] * TILESIZE)) {
            activeMove.unit.sprite.y += 3;
          }
          if (activeMove.unit.sprite.y > (activeMove.currentDest[1] * TILESIZE)) {
            activeMove.unit.sprite.y -= 3;
          }

          if (activeMove.unit.sprite.x == (activeMove.currentDest[0] * TILESIZE) && activeMove.unit.sprite.y == (activeMove.currentDest[1] * TILESIZE)){
            activeMove.currentIndex += 1;
            if (activeMove.path[activeMove.currentIndex]) activeMove.currentDest = activeMove.path[activeMove.currentIndex];
            else activeMove = {};
          }
        } else {
          activeMove.currentDest = activeMove.path[0];
          activeMove.currentIndex = 0;
          console.log("setting destination to " + activeMove.currentDest)
        }
      }
      if (game.input.activePointer.withinGame)
      {
          game.input.enabled = true;
          if (game.input.keyboard.isDown(Phaser.Keyboard.W)){
            game.camera.y -= 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.A)){
            game.camera.x -= 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.S)){
            game.camera.y += 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.D)){
            game.camera.x += 5;
          }

          if (game.input.keyboard.isDown(Phaser.Keyboard.ESC)){
            selectedUnit = null;
            cursor.x = -48;
            cursor.y = -48;
            clr();
            if (myTurn()) print("It is your turn.");
            else print("It is your opponents turn.");
          }
      }
      else
      {
          game.input.enabled = false;
      }


    }

});
</script>
</head>
<body>
<table>
<tr><td valign="top" width="50%">
<p>Click "Open" to create a connection to the server,
"Send" to send a message to the server and "Close" to close the connection.
You can change the message and send multiple times.
<p>
<form>
<button id="open">Open</button>
<button id="close">Close</button>
<p><input id="input" type="text" value="new">
<button id="send">Send</button>
<br>
</form>
<button id="endturn">End Turn</button>
</td><td valign="top" width="50%">
<div id="weapons"></div>
</td></tr></table>
<div id="game">

</div>
<div id="output"></div>
<div id="hud">
<img src="public/client/assets/hud.png">
<div id="hud-output"></div>
<div id="stat-output"></div>
</img>
</div>
<div id="weapons-hud">
  <img src="public/client/assets/weaponshud.png">
  <div id="weapons-output"></div>
  </img>
</div>
</body>
</html>

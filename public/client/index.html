<!DOCTYPE html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="/public/dist/phaser.js"></script>
  <style type="text/css">
      body {
          margin: 0;
      }
      #game {
        position: absolute;
        top: 150px;
        left: 0;
      }

      #endturn {
        display: none;
      }
  </style>
<script>
window.addEventListener("load", function(evt) {

    var output = document.getElementById("output");
    var input = document.getElementById("input");
    var ws;

    var print = function(message) {
        var d = document.createElement("div");
        d.innerHTML = message;
        output.appendChild(d);
    };

    var clr = function() {
        output.innerHTML = '';
    };

    document.getElementById("open").onclick = function(evt) {
        if (ws) {
            return false;
        }
        ws = new WebSocket("{{.}}");
        ws.onopen = function(evt) {
            print("OPEN");
            createGame();
        }
        ws.onclose = function(evt) {
            print("CLOSE");
            ws = null;
        }
        ws.onmessage = function(evt) {
            print("RESPONSE: " + evt.data);
            console.log(JSON.parse(evt.data));
            var message = JSON.parse(evt.data);
            switch (message.MessageType) {
              case 'team':
                myTeam = parseInt(message.Message)
                if (myTeam == 0) myColor = "red";
                else myColor = "blue";
                console.log(message);
                console.log('got team message, on team ' + myTeam)
                break;
              case 'announce':
                //alert(message.Message);
                break;
              case 'map_data':
                clearMap();
                inGame = true;
                loadMap(message);
                break;
              case 'game_start_army_data':
                var m = JSON.parse(message.Message);
                console.log(m);
                loadUnits(m);
                cursor = game.add.sprite(0, 0, 'tile_outline_' + myColor);
                break;
              case 'game_turn':
                currentTurn = parseInt(message.Message);
                clr();
                var btn = document.getElementById('endturn');
                if (myTurn()) {
                  btn.style.display = 'block'
                  print("It's your turn!");
                } else {
                  print("Your opponents turn has begun");
                  btn.style.display = 'none'
                }
                break;
              default:
                console.log("Message " + message + " recieved with no handler!")
            }
        }
        ws.onerror = function(evt) {
            print("ERROR: " + evt.data);
        }
        return false;
    };

    document.getElementById("send").onclick = function(evt) {
        if (!ws) {
            return false;
        }
        switch (input.value) {
          case 'new':
            newMap();
            break;
          default:
            break;
        }
        print("SEND: " + input.value);
        //ws.send(input.value);
        return false;
    };

    document.getElementById('endturn').onclick = function(evt) {
      ws.send('end_turn');
    }

    document.getElementById("close").onclick = function(evt) {
        if (!ws) {
            return false;
        }
        ws.close();
        return false;
    };

    function createGame(){
      var game = new Phaser.Game(1280, 720, Phaser.AUTO, 'game', { preload: preload, create: create, update: update });
      //message = JSON.parse(message.Message);
      //game.currentMapData = message.Map;
      window.game = game;
    }

    /* PHASER GAME CLIENT BEGINS HEREEEEEEE */


    var tileArray = [[]];
    var unitHash = {};
    var selectedTile = 1;
    var TILESIZE = 48;
    var key1;
    var key2;
    var key3;
    var key4;
    var keyQ;
    var keyE;
    var mouseDown = false;
    var inGame = false;
    var myTeam = null;
    var currentTurn = null;
    var myColor = null;
    var cursor = null;

    function myTurn() {
      return currentTurn === myTeam;
    }

    function preload() {
      //
      game.load.image('tile_outline', '/public/client/assets/sprites/tiles/tile_outline.png');
      game.load.image('tile_outline_red', 'public/client/assets/sprites/tiles/tile_outline_red.png');
      game.load.image('tile_outline_blue', 'public/client/assets/sprites/tiles/tile_outline_blue.png');
      game.load.image('grass1', 'public/client/assets/sprites/tiles/grass1.png');
      game.load.image('water1', 'public/client/assets/sprites/tiles/water1.png');
      game.load.image('castle1', 'public/client/assets/sprites/tiles/castle1.png');
      game.load.image('blank', 'public/client/assets/sprites/tiles/blank.png');
      game.load.image('rock1', 'public/client/assets/sprites/tiles/rock1.png');
      game.load.image('archerguy_red', 'public/client/assets/sprites/units/archerguy_red.png');
      game.load.image('archerguy_blue', 'public/client/assets/sprites/units/archerguy_blue.png');
    }

    var Unit = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      if (params.team == 0) this.color = "red";
      else this.color = "blue";
      this.team = params.team;
      this.key = key + "_" + this.color;
      this.sprite = game.add.sprite(x, y, this.key);
      this.sprite.inputEnabled = true;
      this.owner = params.Owner || 0;
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;

      this.uid = params.Uid;
      this.attributes = params.Attributes;

      var self = this;

      this.sprite.events.onInputDown.add(function(){
        clr();
        if (myTeam == self.team)
          print("friendly unit: " + self.uid);
        else
          print("enemy unit: " + self.uid);
        print("team: " + self.color)
        print("attributes: " + JSON.stringify(self.attributes))
      });


      this.sprite.events.onInputDown.add(function(){
        cursor.x = self.x * TILESIZE;
        cursor.y = self.y * TILESIZE;
      })

    }

    var loadUnits = function(ary){
      for (var i = 0; i < ary.length; i++){
        for (var k = 0; k < ary[i].Squads.length; k++){
          for (var l = 0; l < ary[i].Squads[k].Grunts.length; l++) {
            var u = ary[i].Squads[k].Grunts[l];
            u.team = i;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, 'archerguy', u);
          }
          if (ary[i].Squads[k].Leader) {
            var u = ary[i].Squads[k].Leader;
            u.team = i;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, 'archerguy', u);
          }
        }
      }
    }

    var MapTile = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      this.key = params.Key || key;
      this.sprite = game.add.sprite(x, y, this.key);
      this.overlayKey = params.OverlayKey || 'blank';

      if (inGame && this.overlayKey != 'tile_outline_red' && this.overlayKey != 'tile_outline_blue'){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      } else if (!inGame){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      }
      this.sprite.inputEnabled = true;
      this.walkable = params.Walkable || false;
      this.spawn = params.Spawn || false;
      this.spawnTeam = params.SpawnTeam || 0;
      this.tileType = params.TileType || '';
      this.castle = params.Castle || false;
      this.capturable = params.Capturable || false;
      this.owner = params.Owner || 0;
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;

      var self = this;

      var updateTexture = function(key, layer){
        switch (layer) {
          case 2:
            self.overlay.loadTexture(key);
            self.overlayKey = key;
            break;
          default:
            self.sprite.loadTexture(key);
            self.key = key;
            break;
        }

      }

      this.sprite.events.onInputDown.add(function(){
        if (!inGame) {
          switch (selectedTile) {
            case 1:
              updateTexture('grass1');
              self.tileType = 'grass';
              self.walkable = true;
              break;
            case 2:
              updateTexture('water1');
              self.tileType = 'water';
              self.walkable = false;
              break;
            case 3:
              updateTexture('castle1', 2);
              self.castle = true;
              self.capturable = true;
              break;
            case 4:
              updateTexture('blank', 2);
              self.castle = false;
              self.capturable = false;
              break;
            case 5:
              updateTexture('tile_outline_red', 2);
              self.spawnTeam = 0;
              self.spawn = true;
              break;
            case 6:
              updateTexture('tile_outline_blue', 2);
              self.spawnTeam = 1;
              self.spawn = true;
              break;
            default:
              break;
          }
        }
      }, this);
    }


    var updateSelectedTile = function(newVal){
      console.log(newVal.event.code)

      switch (newVal.event.code) {
        case 'Digit1':
          selectedTile = 1;
          break;
        case 'Digit2':
          selectedTile = 2;
          break;
        case 'Digit3':
          selectedTile = 3;
          break;
        case 'Digit4':
          selectedTile = 4;
          break;
        case 'KeyQ':
          if (selectedTile == 5) selectedTile = 6;
          else if (selectedTile == 6) selectedTile = 5;
          else selectedTile = 5;
          break;
        default:
          selectedTile = 1;
      }

      print(selectedTile);

    }

    function createMapArray(w, h){
      var tilesArray = new Array(w);
      for (var i = 0; i < w; i++) {
        tilesArray[i] = new Array(h);
        for (var k = 0; k < h; k++) {
          tilesArray[i][k] = new MapTile(i * TILESIZE, k * TILESIZE, 'rock1');
        }
      }
      return tilesArray;
    }

    function clearMap() {
      //debugger;
      var w = tileArray.length;
      var h = tileArray[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
          if (tileArray[i][k]) {
            tileArray[i][k].sprite.destroy();
            if (tileArray[i][k].overlay) tileArray[i][k].overlay.destroy();
          }
        }
      }
      tileArray = [[]];
    }

    function loadMap(mapAry){
      mapAry = JSON.parse(mapAry.Message).Map;
      var w = mapAry.length;
      var h = mapAry[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
          t = mapAry[i][k];
          mapAry[i][k] = new MapTile(0, 0, '', t);
        }
      }
      tileArray = mapAry;
      //debugger;
    }

    function newMap() {
      clearMap();
      tileArray = createMapArray(30, 25);
    }

    function create() {
      //tileArray = createMapArray(30, 25);
      key1 = game.input.keyboard.addKey(Phaser.Keyboard.ONE);
      key1.onDown.add(updateSelectedTile, this);
      key2 = game.input.keyboard.addKey(Phaser.Keyboard.TWO);
      key2.onDown.add(updateSelectedTile, this);
      key3 = game.input.keyboard.addKey(Phaser.Keyboard.THREE);
      key3.onDown.add(updateSelectedTile, this);
      key4 = game.input.keyboard.addKey(Phaser.Keyboard.FOUR);
      key4.onDown.add(updateSelectedTile, this);

      keyE = game.input.keyboard.addKey(Phaser.Keyboard.E);
      keyE.onDown.add(exportMap, this);

      keyQ = game.input.keyboard.addKey(Phaser.Keyboard.Q);
      keyQ.onDown.add(updateSelectedTile, this);

      game.world.scale.set(1);
      game.camera.bounds = undefined;
    }

    function exportMap(){
      var ret = {};
      ret.message = {};
      ret.message.map = tileArray;
      for (var i = 0; i < ret.message.map.length; i++) {
        for (var k = 0; k < ret.message.map[1].length; k++) {
          var tileJson = {};
          var tileObj = ret.message.map[i][k];
          tileJson.key = tileObj.key;
          tileJson.overlayKey = tileObj.overlayKey;
          tileJson.walkable = tileObj.walkable;
          tileJson.spawn = tileObj.spawn;
          tileJson.spawnTeam = tileObj.spawnTeam;
          tileJson.tileType = tileObj.tileType;
          tileJson.castle = tileObj.castle;
          tileJson.capturable = tileObj.capturable;
          tileJson.x = tileObj.x;
          tileJson.y = tileObj.y;
          print(tileJson.x + " " + tileJson.y)
          ret.message.map[i][k] = tileJson;
        }
      }
      //console.log(ret);
      ret.message = JSON.stringify(ret.message);
      ret.messageType = "map_export_data";
      ws.send(JSON.stringify(ret));
    }

    function update() {
      if (game.input.activePointer.withinGame)
      {
          game.input.enabled = true;
      }
      else
      {
          game.input.enabled = false;
      }

      if (game.input.keyboard.isDown(Phaser.Keyboard.W)){
        game.camera.y -= 5;
      }
      if (game.input.keyboard.isDown(Phaser.Keyboard.A)){
        game.camera.x -= 5;
      }
      if (game.input.keyboard.isDown(Phaser.Keyboard.S)){
        game.camera.y += 5;
      }
      if (game.input.keyboard.isDown(Phaser.Keyboard.D)){
        game.camera.x += 5;
      }
    }

});
</script>
</head>
<body>
<table>
<tr><td valign="top" width="50%">
<p>Click "Open" to create a connection to the server,
"Send" to send a message to the server and "Close" to close the connection.
You can change the message and send multiple times.
<p>
<form>
<button id="open">Open</button>
<button id="close">Close</button>
<p><input id="input" type="text" value="new">
<button id="send">Send</button>
<br>
</form>
<button id="endturn">End Turn</button>
</td><td valign="top" width="50%">
<div id="output"></div>
</td></tr></table>
<div id="game">

</div>
</body>
</html>

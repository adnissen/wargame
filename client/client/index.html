<!DOCTYPE html>
<head>
<meta charset="utf-8">
<script type="text/javascript" src="../dist/phaser.js"></script>
<script type="text/javascript" src="../dist/easyfind.min.js"></script>
<script type="text/javascript" src="../dist/sha.js"></script>
<script type="text/javascript" src="../dist/sweetalert2.min.js"></script>

<link rel="stylesheet" href="../dist/sweetalert2.min.css">

  <style type="text/css">
      body {
          margin: 0;
          background-color: #333;
          font-family: pixelFont;
      }

      #game {
        position: absolute;
        top: 50px;
        left: 0;
        width: 800px;
        height: 600px;
      }

      #output {
        position: absolute;
        top: 50px;
        left: 800px;
        color: white;
        height: 400px;
        overflow: scroll;
      }

      #output::-webkit-scrollbar {
        display: none;
      }

      #hud {
        position: absolute;
        top: 600px;
        left: 0;
      }

      #hud-output {
        color: #FFF;
        position: absolute;
        top: 45px;
        left: 10px;
      }

      #weapons-hud {
        position: absolute;
        top: 450px;
        left: 800px;
      }

      #weapons-output {
        position: absolute;
        top: 20px;
        left: 10px;
        color: white;
      }

      #endturn {
        position: absolute;
        top: 20px;
        left: 400px;
        display: none;
      }


      #stat-output {
        color: #FFF;
        position: absolute;
        top: 45px;
        left: 250px;
      }

      #card-output {
        color: #FFF;
        position: absolute;
        top: 45px;
        left: 430px;
      }

      @font-face {
          font-family: pixelFont;
          src: url(../client/assets/VCR_OSD_MONO_1.001.ttf);
      }
  </style>
<script>

var loginStatus = "";
var loggedIn = false;
var clientData = {};
var mapEditorBrush = {};
var mapEditorTool = "";
window.addEventListener("load", function(evt) {
    var output = document.getElementById("output");
    var input = document.getElementById("input");
    var ws;

    var print = function(message, id) {
        var d = document.createElement("div");
        d.innerHTML = message;
        if (id) {
          var o = document.getElementById(id);
          o.appendChild(d);
          lastMessage[id] = message;
        } else {
          output.appendChild(d);
          output.scrollTop = output.scrollHeight;
          lastMessage['default'] = message;
        }
    };

    var clr = function(id) {
      if (id) {
        var o = document.getElementById(id);
        o.innerHTML = '';
      }
      else output.innerHTML = '';
    };

    var loginModal = function() {
        //LOGIN
        swal({
        title: 'Login',
        html: '<input id="username" class="swal2-input" placeholder="username" type="text"></input><br><input id="password" class="swal2-input" type="password" placeholder="password"></input>',
        confirmButtonText: 'Submit',
        showLoaderOnConfirm: true,
        preConfirm: function(email) {
          return new Promise(function(resolve, reject) {
            loginStatus = "";
            data = {};
            data.MessageType = "login";
            data.Message = {};
            data.Message.username = document.getElementById('username').value;
            data.Message.password = Sha256.hash(document.getElementById('password').value);
            data.Message = JSON.stringify(data.Message);
            data = JSON.stringify(data);
            ws.send(data);
            ls = setInterval(function() {
              if (loginStatus != "") {
                clearInterval(ls);
                if (loginStatus == "failure") {
                  reject('invalid login!');
                } else {
                  loggedIn = true;
                  resolve();
                }
              }
            }, 100);
          });
        },
        allowOutsideClick: false
      }).then(function(email) {
        createGame()
      })
    }

    var createAccountModal = function(){
      //CREATE ACCOUNT
      swal({
      title: 'Create Account',
      html: '<input id="username" class="swal2-input" placeholder="username" type="text"></input><br><input id="email" class="swal2-input" placeholder="email" type="email"></input><br><input id="password" class="swal2-input" type="password" placeholder="password"></input><br><input id="invitecode" class="swal2-input" placeholder="invite code" type="text"></input>',
      confirmButtonText: 'Submit',
      showLoaderOnConfirm: true,
      preConfirm: function(email) {
        return new Promise(function(resolve, reject) {
          loginStatus = "";
          data = {};
          data.MessageType = "create_user";
          data.Message = {};
          data.Message.username = document.getElementById('username').value;
          data.Message.password = Sha256.hash(document.getElementById('password').value);
          data.Message.email = document.getElementById('email').value;
          data.Message.code = document.getElementById('invitecode').value;
          data.Message = JSON.stringify(data.Message);
          data = JSON.stringify(data);
          ws.send(data);
          ls = setInterval(function() {
            if (loginStatus != "") {
              clearInterval(ls);
              if (loginStatus == "failure") {
                reject('invalid login!');
              } else {
                loggedIn = true;
                resolve();
              }
            }
          }, 100);
        });
      },
      allowOutsideClick: false
      }).then(function(email) {
        createGame()
      })
    }

    var makeConnection = function(event) {
        if (ws) {
            return false;
        }

        if (process.env.ENV == "local") ws = new WebSocket("ws://localhost:8080"); //local
        else ws = new WebSocket("ws://198.199.122.68");  //production

        ws.onopen = function(evt) {
          swal({
            title: 'Elder Runes',
            text: "Welcome to the Elder Runes closed alpha!",
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Login',
            cancelButtonText: 'Create Account',
            allowOutsideClick: false
          }).then(loginModal, createAccountModal)
            //print("OPEN");

            //createGame();
        }
        ws.onclose = function(evt) {
            print("CLOSE");
            ws = null;
        }
        ws.onmessage = function(evt) {
            console.log(JSON.parse(evt.data));
            var message = JSON.parse(evt.data);
            switch (message.MessageType) {
              case 'code':
                console.log(message.Message);
                break;
              case 'login_result':
                loginStatus = message.Message;
                break;
              case 'create_user_result':
                loginStatus = message.Message;
                break;
              case 'team':
                myTeam = parseInt(message.Message)
                if (myTeam == 0) myColor = "red";
                else myColor = "blue";
                break;
              case 'game_end':
                var winner = JSON.parse(message.Message).winner;
                console.log("WINNER IS " + winner);
                if (winner == myTeam) print("You won!");
                else print("You lost.");
                clearMap();
                displayMainMenu();
                inGame = false;
                break;
              case 'announce':
                //alert(message.Message);
                print(message.Message);
                //debugger;
                break;
              case 'map_data':
                var t = setInterval(function(){
                  if (!fullyLoaded) return;
                  clearMap();
                  inGame = true;
                  loadMap(message);
                  clearInterval(t);
                }, 100)
                break;
              case 'client_information':
                var data = JSON.parse(message.Message);
                clientData = data;
                break;
              case 'game_start_army_data':
                //window.game.stage.disableVisibilityChange = true;
                var t = setInterval(function(){
                  if (!fullyLoaded) return;
                  var m = JSON.parse(message.Message);
                  console.log(m);
                  loadUnits(m);
                  cursor = game.add.sprite(0, 0, 'tile_outline_' + myColor);
                  clearInterval(t);
                  updateScores(0, 0);
                }, 100);
                break;
              case 'game_points_update':
                var m = JSON.parse(message.Message);
                updateScores(m[0], m[1]);
                break;
              case 'game_move':
                var m = JSON.parse(message.Message);
                var u = unitHash[m.uid];
                tileArray[u.x][u.y].unit = '';
                u.x = m.moves[m.moves.length - 1][0];
                u.y = m.moves[m.moves.length - 1][1];
                tileArray[u.x][u.y].unit = u.uid;
                //u.sprite.x = u.x * TILESIZE;
                //u.sprite.y = u.y * TILESIZE;
                var timer = setInterval(function(){
                  if (!activeMove.path && !activeMove.unit){
                    activeMove.path = m.moves;
                    activeMove.unit = u;
                    clearTimeout(timer);
                  }
                }, 100)
                u.actionCount = u.actionCount - 1;
                if (u.actionCount <= 0) {
                  u.combatCount = 0;
                  u.sprite.tint = 0x333333;
                }
                if (selectedUnit == u) {
                  cursor.x = u.x * TILESIZE;
                  cursor.y = u.y * TILESIZE;
                  u.showInfo();
                  DeselectRange();
                  u.showRange();
                }
                break;
              case 'game_use_weapon':
                var m = JSON.parse(message.Message);
                var u = unitHash[m.uid];
                var t = unitHash[m.target];
                var damage = m.damage;
                var roll = m.roll;
                var weapon;
                for (var i = 0; i < u.attributes.Weapons.length; i++) {
                  if (m.weapon === u.attributes.Weapons[i].Uid) {
                    weapon = u.attributes.Weapons[i];
                  }
                }
                weapon.UsesRemaining -= 1;
                print(u.displayName + " rolls " + roll + "(+" + weapon.Atk + ") against " + t.displayName + "(" + t.attributes.Def + ")!");
                u.actionCount = u.actionCount - 1;
                u.combatCount = u.combatCount - 1;

                if (u.actionCount <= 0) {
                  u.combatCount = 0;
                  u.sprite.tint = 0x333333;
                }
                var style = { font: "32px pixelFont", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle" };
                var txtX = t.sprite.x + 16;
                var txtY = t.sprite.y;
                //temporary visual hack
                var dist = u.distanceToTile(t.x, t.y)
                if (dist > 1) {
                  //ranged
                  var atk = game.add.sprite(u.sprite.x, u.sprite.y, 'single_bullet');
                  var tween = game.add.tween(atk).to({x: t.sprite.x, y: t.sprite.y}, 50 * dist, Phaser.Easing.Linear.None, true);
                  tween.onComplete.add(function(){
                    atk.destroy();
                  });
                } else {
                  //melee animation
                  var atk = game.add.sprite(t.sprite.x, t.sprite.y, 'melee_single');
                  game.add.tween(atk.scale).to({x: 0, y: 0}, 1500, Phaser.Easing.Quintic.In, true);
                  var tween = game.add.tween(atk).to({x: atk.x + 24, y: atk.y + 24}, 1500, Phaser.Easing.Quintic.In, true);
                  tween.onComplete.add(function(){
                    atk.destroy();
                  });
                }
                if (damage > 0) {
                  print("Hit for " + damage + "!");
                  style.fill = "red"
                  var text = "-" + damage;
                  t.attributes.Hps = t.attributes.Hps - damage;
                  if (t.attributes.Hps <= 0) {
                    print(t.displayName + " has died.");
                    t.sprite.destroy();
                    tileArray[t.x][t.y].unit = null;
                  }
                } else {
                  print("miss!");
                  var text = "miss!";
                }
                t.updateHitpoints();
                var obj = game.add.text(txtX, txtY, text, style);
                activeNotifications.push(obj);
                if (selectedUnit) selectedUnit.showInfo();
                break;
              case 'game_turn':
                currentTurn = parseInt(message.Message);
                var btn = document.getElementById('endturn');
                if (myTurn()) {
                  btn.style.display = 'block'
                  print("It's your turn!");
                } else {
                  print("Your opponents turn has begun");
                  btn.style.display = 'none'
                }
                resetActions();
                break;
              default:
                console.log("Message " + message + " recieved with no handler!")
            }
        }
        ws.onerror = function(evt) {
            print("ERROR: " + evt.data);
        }
        return false;
    };


    makeConnection();

    document.getElementById("send").onclick = function(evt) {
        if (!ws) {
            return false;
        }
        switch (input.value) {
          case 'new':
            newMap();
            break;
          case 'code':
            ws.send('code');
            break;
          default:
            break;
        }
        print("SEND: " + input.value);
        //ws.send(input.value);
        return false;
    };

    document.getElementById('endturn').onclick = function(evt) {
      ws.send('end_turn');
    }

    function updateScores(p1, p2) {
      if (guiRedScore){
        guiRedScore.destroy();
        guiBlueScore.destroy();
      }
      var style = { font: "24px pixelFont", fill: "#fff", boundsAlignH: "center", boundsAlignV: "middle" };
      guiRedScore = game.add.text(10, 10, "Red Score: " + p1, style);
      guiBlueScore = game.add.text(600, 10, "Blue Score: " + p2, style);
      guiRedScore.fixedToCamera = true;
      guiBlueScore.fixedToCamera = true;
    }

    function createGame(){
      var game = new Phaser.Game(800, 600, Phaser.AUTO, 'game', { preload: preload, create: create, update: update });
      //message = JSON.parse(message.Message);
      //game.currentMapData = message.Map;
      window.game = game;
    }

    /* PHASER GAME CLIENT BEGINS HEREEEEEEE */


    var tileArray = [[]];
    var overlayArray = null;
    var unitHash = {};
    var activeNotifications = [];
    var selectedTile = 1;
    var TILESIZE = 48;
    var key1;
    var key2;
    var key3;
    var key4;
    var keyQ;
    var keyE;
    var mouseDown = false;
    var inGame = false;
    var myTeam = null;
    var currentTurn = null;
    var myColor = null;
    var cursor = null;
    var selectedUnit = null;
    var mapMatrix = null;
    var activeMove = {};
    var fullyLoaded = false;
    var weaponsUi = document.getElementById("weapons");
    var calculatingPaths = {};
    var guiRedScore;
    var guiBlueScore;
    var searching = false;
    var lastMessage = {};

    function myTurn() {
      return currentTurn === myTeam;
    }

    function newMatrix() {
      var w = tileArray.length;
      var h = tileArray[0].length;
      //var matrix = new PF.Grid(w, h);
      var matrix = new Array(w);
      for (var i = 0; i < w; i++) {
        matrix[i] = new Array(h);
        for (var k = 0; k < h; k++) {
          if (tileArray[i][k].walkable && !tileArray[i][k].unit) {
            if (tileArray[i][k].tileType != 'grass') matrix[i][k] = tileArray[i][k].movementModifier();
            else matrix[i][k] = 1;
          } else {
            matrix[i][k] = 0;
          }
        }
      }
      window.tileArray = tileArray;
      return matrix
    }

    function flipGrid(grid) {
      var w = grid.length;
      var h = grid[0].length;
      var matrix = new Array(h);
      for (var i = 0; i < h; i++) {
        matrix[i] = new Array(w);
        for (var k = 0; k < w; k++) {
          matrix[i][k] = grid[k][i];
        }
      }
      return matrix;
    }

    function findPath(x1, y1, x2, y2, cb) {
      var easystar = new EasyStar.js();
      var grid = newMatrix();
      var id = Date.now();
      easystar.setGrid(flipGrid(grid));
      easystar.setAcceptableTiles([1, 2]);
      easystar.setTileCost(2, 2);
      var finalPath = null;
      calculatingPaths[id] = true;
      easystar.findPath(x1, y1, x2, y2, function (path) {
        if (path === null){
          finalPath = [];
        } else {
          finalPath = path;
        }
        delete calculatingPaths[id];
        cb(path);
      });
      var t = setInterval(function() {
        if (!finalPath) easystar.calculate();
        else clearTimeout(t);
      }, 10)
    }

    function pathfindingActive() {
      if (Object.keys(calculatingPaths).length > 0) return true;
      else return false;
    }

    function preload() {
      game.load.onLoadComplete.add(function(){
        fullyLoaded = true;
        console.log("loaded: " + fullyLoaded);
      }, this);
      //
      game.load.spritesheet('terrain', '../client/assets/sprites/tiles/oryx_16bit_fantasy_world_trans_48.png', 48, 48);
      game.load.image('tile_outline', '../client/assets/sprites/tiles/tile_outline.png');
      game.load.image('tile_outline_red', '../client/assets/sprites/tiles/tile_outline_red.png');
      game.load.image('tile_outline_blue', '../client/assets/sprites/tiles/tile_outline_blue.png');
      game.load.image('red_overlay', '../client/assets/sprites/tiles/red_overlay.png');
      game.load.image('purple_overlay', '../client/assets/sprites/tiles/purple_overlay.png');
      game.load.image('white_overlay', '../client/assets/sprites/tiles/white_overlay.png');
      game.load.image('flag', '../client/assets/sprites/flag.png');
      game.load.image('flag_red', '../client/assets/sprites/flag_red.png');
      game.load.image('flag_blue', '../client/assets/sprites/flag_blue.png');
      game.load.image('grass1', '../client/assets/sprites/tiles/grass1.png');
      game.load.image('mountain1', '../client/assets/sprites/tiles/mountain1.png');
      game.load.image('forest1', '../client/assets/sprites/tiles/forest1.png');
      game.load.image('water1', '../client/assets/sprites/tiles/water1.png');
      game.load.image('castle1', '../client/assets/sprites/tiles/castle1.png');
      game.load.image('blank', '../client/assets/sprites/tiles/blank.png');
      game.load.image('rock1', '../client/assets/sprites/tiles/rock1.png');

      //units
      game.load.image('archerguy_red', '../client/assets/sprites/units/archerguy_red.png');
      game.load.image('archerguy_blue', '../client/assets/sprites/units/archerguy_blue.png');
      game.load.image('stout_guard_blue', '../client/assets/sprites/units/stout_guard_blue.png');
      game.load.image('stout_guard_red', '../client/assets/sprites/units/stout_guard_red.png');
      game.load.image('spearman_red', '../client/assets/sprites/units/spearman_red.png');
      game.load.image('spearman_blue', '../client/assets/sprites/units/spearman_blue.png');
      game.load.image('mounted_knight_red', '../client/assets/sprites/units/mounted_knight_red.png');
      game.load.image('mounted_knight_blue', '../client/assets/sprites/units/mounted_knight_blue.png');
      game.load.image('farmer_man_red', '../client/assets/sprites/units/farmer_man_red.png');
      game.load.image('farmer_man_blue', '../client/assets/sprites/units/farmer_man_blue.png');
      game.load.image('goblin_dagger_blue', '../client/assets/sprites/units/goblin_dagger_blue.png');
      game.load.image('goblin_dagger_red', '../client/assets/sprites/units/goblin_dagger_red.png');
      game.load.image('goblin_archer_blue', '../client/assets/sprites/units/goblin_archer_blue.png');
      game.load.image('goblin_archer_red', '../client/assets/sprites/units/goblin_archer_red.png');
      game.load.image('wild_archer_blue', '../client/assets/sprites/units/wild_archer_blue.png');
      game.load.image('wild_archer_red', '../client/assets/sprites/units/wild_archer_red.png');


      //tiles
      game.load.image('river1', '../client/assets/sprites/tiles/river1.png');
      game.load.image('river2', '../client/assets/sprites/tiles/river2.png');
      game.load.image('river3', '../client/assets/sprites/tiles/river3.png');
      game.load.image('river4', '../client/assets/sprites/tiles/river4.png');
      game.load.image('river5', '../client/assets/sprites/tiles/river5.png');
      game.load.image('river6', '../client/assets/sprites/tiles/river6.png');
      game.load.image('river7', '../client/assets/sprites/tiles/river7.png');
      game.load.image('river8', '../client/assets/sprites/tiles/river8.png');
      game.load.image('river9', '../client/assets/sprites/tiles/river9.png');
      game.load.image('river10', '../client/assets/sprites/tiles/river10.png');
      game.load.image('river11', '../client/assets/sprites/tiles/river11.png');
      game.load.image('river12', '../client/assets/sprites/tiles/river12.png');
      game.load.image('river13', '../client/assets/sprites/tiles/river13.png');
      game.load.image('river14', '../client/assets/sprites/tiles/river14.png');
      game.load.image('river15', '../client/assets/sprites/tiles/river15.png');

      //fx
      game.load.image('melee_single', '../client/assets/sprites/melee_single.png');
      game.load.image('single_bullet', '../client/assets/sprites/single_bullet.png')


      game.load.image('mmbg', '../client/assets/mainmenubackground.png');
      game.load.image('playbutton', '../client/assets/playbutton.png');
      game.load.image('searchingbutton', '../client/assets/searchingbutton.png');
    }

    function resetActions() {
      Object.keys(unitHash).forEach(function (key) {
          var unit = unitHash[key]
          unit.actionCount = 2;
          unit.combatCount = 1;
          // iteration code
          unit.sprite.tint = 0xffffff;
      })
    }

    function calculateWater() {
      var w = tileArray.length;
      var h = tileArray[0].length;
      for (var i = 0; i < w; i++) {
        for (var k = 0; k < h; k++) {
            if (tileArray[i][k].tileType == "river"){
              var left = false;
              var right = false;
              var up = false;
              var down = false;
              if (tileArray[i+1] && tileArray[i+1][k].tileType == "river") right = true;
              if (tileArray[i-1] && tileArray[i-1][k].tileType == "river") left = true;
              if (tileArray[i][k+1] && tileArray[i][k+1].tileType == "river") down = true;
              if (tileArray[i][k-1] && tileArray[i][k-1].tileType == "river") up = true;
              var key;
              if (left && right && down && up) key = 5;
              else if (left && down && right) key = 10;
              else if (left && up && right) key = 11;
              else if (left && up && down) key = 12;
              else if (up && down & right) key = 13;
              else if (right && down) key = 1;
              else if (left && right) key = 2;
              else if (left && down) key = 3;
              else if (up && down) key = 6;
              else if (up && left) key = 9;
              else if (right && up) key = 7;
              else if (up) key = 6;
              else if (down) key = 6;
              else key = 2;
              console.log(key);
              //debugger;
              tileArray[i][k].updateTexture('river' + key, 2);
            }
        }
      }
    }

    var DeselectRange = function(){
      if (overlayArray) {
        var w = overlayArray.length;
        var h = overlayArray[0].length;
        for (var i = 0; i < w; i++) {
          for (var k = 0; k < h; k++) {
            if (overlayArray[i][k]) {
              overlayArray[i][k].destroy();
            }
          }
        }
      }
      overlayArray = null;
    }

    var Unit = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      if (params.team == 0) this.color = "red";
      else this.color = "blue";
      this.team = params.team;
      this.key = key + "_" + this.color;
      this.sprite = game.add.sprite(x, y, this.key);
      this.displayName = params.DisplayName;
      this.sprite.inputEnabled = true;
      this.owner = params.Owner || 0;
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;
      this.actionCount = 2;
      this.combatCount = 1;
      this.leader = params.leader || false;
      this.uid = params.Uid;
      this.attributes = params.Attributes;
      this.value = params.Value;
      this.defenseMod = 0;
      this.attackMod = 0;
      this.movementMod = 0;
      this.damageMod = 0;
      var style = { font: "20px pixelFont", fill: "red", boundsAlignH: "center", boundsAlignV: "middle" };
      this.hpsprite = this.sprite.addChild(game.make.text(TILESIZE - 15, TILESIZE - 15, this.attributes.Hps, style))
      tileArray[this.x][this.y].unit = this.uid;

      var self = this;

      this.sprite.events.onInputDown.add(function(){
        self.showInfo();
        DeselectRange();
        self.showRange();
      });

     self.distanceToTile = function(x, y) {
       return Math.abs(self.x - x) + Math.abs(self.y - y);
     }

     self.updateHitpoints = function() {
       this.hpsprite.setText(self.attributes.Hps);
     }

     self.hasSightTo = function(x, y) {
       var vision = true;
       var bresenham = makeBresenham(self.x, self.y, x, y);
       while (bresenham.hasNext()) {
				 var p = bresenham.next();
         var t = tileArray[p.x][p.y]
         if (p.x == self.x && p.y == self.y) continue;
         if (p.x == x && p.y == y) continue;
				 if (t.blocksVision || t.unit) {
			     return false;
			   }
			 }
			 return true;
     }

     self.showRange = function(){
       //first and foremost, if a unit doesn't have any more actions, we don't need to do any of this
       if (self.actionCount <= 0) {
         return;
       }
       var maxAttackRange = 1;
       var minAttackRange = 99999;
       self.attributes.Weapons.forEach(function(w){
         if (w.Rng > maxAttackRange) maxAttackRange = w.Rng;
         if (w.MinRng < minAttackRange) minAttackRange = w.MinRng;
       })
       console.log("MAX ATTACK RANGE: " + maxAttackRange)
       var w = tileArray.length;
       var h = tileArray[0].length;
       overlayArray = new Array(tileArray.length);
       var goodTiles = [];
       for (var i = 0; i < tileArray.length; i++) {
         overlayArray[i] = new Array(tileArray[0].length);
       }

       for (var i = 0; i < w; i++) {
         //overlayArray[i] = new Array(tileArray.length[0]);
         for (var k = 0; k < h; k++) {
           //this is all disgusting, so let me break it down for you
           //right at the start for every tile it falls into one of two categories: within our speed, and outside of it
           if (self.distanceToTile(i, k) <= self.attributes.Spd) {
             //once we know we have the speed to get to the tile, we need to make sure there is a valid path there, using pathfinding
             findPath(self.x, self.y, tileArray[i][k].x, tileArray[i][k].y, function(path) {
               if (!path) return;
               if (path.length == 0) return;
               var ti = path[path.length - 1].x
               var tk = path[path.length - 1].y
               if (tileArray[ti][tk].walkable && !tileArray[ti][tk].unit && path.length != 0 && path.length - 1 <= self.attributes.Spd) {
                 var pathDistance  = 0;
                 for (var v = 1; v < path.length; v++) {
                   var temp = tileArray[path[v].x][path[v].y];
                   pathDistance += temp.movementModifier();
                 }
                 if (pathDistance <= self.attributes.Spd){
                   //if there's a valid path, it's a nice blue overlay
                   if (overlayArray[ti][tk]) {
                     overlayArray[ti][tk].destroy();
                     overlayArray[ti][tk] = game.add.sprite(tileArray[ti][tk].x * TILESIZE, tileArray[ti][tk].y * TILESIZE, 'purple_overlay');
                     overlayArray[ti][tk].alpha = 0.75;
                   } else {
                     overlayArray[ti][tk] = game.add.sprite(tileArray[ti][tk].x * TILESIZE, tileArray[ti][tk].y * TILESIZE, 'white_overlay');
                     overlayArray[ti][tk].alpha = 0.75;
                   }
                 }
               }
             });
           }

           if (self.distanceToTile(i, k) <= maxAttackRange && self.distanceToTile(i, k) >= minAttackRange && self.hasSightTo(i, k)) {
             if (tileArray[i][k].unit && unitHash[tileArray[i][k].unit].team == myTeam) continue;
              overlayArray[i][k] = game.add.sprite(tileArray[i][k].x * TILESIZE, tileArray[i][k].y * TILESIZE, 'red_overlay');
              overlayArray[i][k].alpha = 0.75;
           }
         }
       }
     }

     self.notifyAnimation = function(key, color){}

     self.showInfo = function(){
       clr('hud-output');
       clr('stat-output');
       clr('weapons-output');
       clr('card-output');
       if (myTeam == self.team)
         print("friendly " + self.displayName, 'hud-output');
       else
         print("enemy " + self.displayName, 'hud-output');
       if (self.leader) print("LEADER", 'hud-output');
       print("remaining actions: " + self.actionCount, 'hud-output');
       print("remaining attacks: " + self.combatCount, 'hud-output');
       print("team: " + self.color, 'hud-output');
       print("hitpoints: " + self.attributes.Hps, 'stat-output');
       print("speed: " + self.attributes.Spd, 'stat-output');
       print("defense: " + self.attributes.Def + " (+" + tileArray[self.x][self.y].defenseModifier() + ")", 'stat-output');
       print("armor: " + self.attributes.Amr, 'stat-output');
       print("value: " + self.value, 'stat-output');

       print("weapons:", "weapons-output");
       print("", "weapons-output");
       self.attributes.Weapons.forEach(function(w){
         print("------------", "weapons-output");
         print(w.DisplayName, "weapons-output");
         print("Durability: " + w.UsesRemaining, "weapons-output");
         print("ATK: " + w.Atk, "weapons-output");
         print("RNG: " + w.Rng, "weapons-output");
         print("DMG: " + w.Dmg, "weapons-output");
         if (w.Keywords){
           w.Keywords.forEach(function(kw) {
             print(kw, "weapons-output");
           })
         }
         print("------------", "weapons-output");
       })

       if (myTurn() && myTeam != self.team && selectedUnit && selectedUnit.team === myTeam && selectedUnit.combatCount > 0) {
         selectedUnit.attributes.Weapons.forEach(function(w){
           print("ATTACK with:", "weapons-output");
           print("------------", "weapons-output");
           print(w.DisplayName, "weapons-output");
           print("Durability: " + w.UsesRemaining, "weapons-output");
           print("ATK: " + w.Atk + " (+" + tileArray[self.x][self.y].attackModifier() + ")", "weapons-output");
           print("RNG: " + w.Rng, "weapons-output");
           print("DMG: " + w.Dmg + " (+" + tileArray[self.x][self.y].damageModifier() + ")", "weapons-output");
           print("HIT: " + 100 - ((self.attributes.Def - w.Atk) * 5) + "%", "weapons-output");
           var useBtn = '<button id="' + w.Uid + '">Use</button>';
           print(useBtn, "weapons-output");
           document.getElementById(w.Uid).addEventListener("click", function(){
             var ret = {};
             ret.messageType = "game_use_weapon";
             ret.message = {};
             ret.message.uid = selectedUnit.uid;
             ret.message.target = self.uid;
             ret.message.weapon = w.Uid;
             ret.message = JSON.stringify(ret.message)
             ws.send(JSON.stringify(ret));
             console.log("attacked with weapon " + w.Uid);
           });
           print("------------", "weapons-output");
         })
       }

       if (self.attributes.Keywords) {
         self.attributes.Keywords.forEach(function(kw){
           print(kw, "card-output");
         });
       }
     }

      this.sprite.events.onInputDown.add(function(){
        if (selectedUnit && selectedUnit.team !== self.team && selectedUnit.combatCount > 0 && selectedUnit.team == myTeam) {

        } else {
          cursor.x = self.x * TILESIZE;
          cursor.y = self.y * TILESIZE;
          selectedUnit = self;
        }
      })

      self.move = function(x, y) {
        findPath(self.x, self.y, x, y, function(path) {
          if (!path) return;
          if (path.length === 0 || path.length - 2 > self.attributes.Spd) {
            return;
          }
          for (var i = 0; i < path.length; i++){
            var ary = [];
            ary.push(path[i].x);
            ary.push(path[i].y);
            path[i] = ary;
          }
          var ret = {};
          ret.messageType = "game_move";
          ret.message = {};
          ret.message.uid = self.uid;
          ret.message.moves = path;
          ret.message = JSON.stringify(ret.message)
          console.log("MOVING ON PATH " + path);
          ws.send(JSON.stringify(ret));
        });
      }

    }

    var loadUnits = function(ary){
      for (var i = 0; i < ary.length; i++){
        for (var k = 0; k < ary[i].Squads.length; k++){
          for (var l = 0; l < ary[i].Squads[k].Grunts.length; l++) {
            var u = ary[i].Squads[k].Grunts[l];
            u.team = i;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, u.Key, u);
          }
          if (ary[i].Squads[k].Leader) {
            var u = ary[i].Squads[k].Leader;
            u.team = i;
            u.leader = true;
            unitHash[u.Uid] = new Unit(u.X * TILESIZE, u.Y * TILESIZE, u.Key, u);
          }
        }
      }
    }

    var MapTile = function(x, y, key, params){
      if (params) {
        x = params.X * TILESIZE;
        y = params.Y * TILESIZE;
      }
      if (!params) params = {};
      this.key = params.Key || key;

      if (inGame && this.overlayKey != 'tile_outline_red' && this.overlayKey != 'tile_outline_blue'){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      } else if (!inGame){
        this.overlay = game.add.sprite(x, y, this.overlayKey);
      }
      if (params.Walkable === false) {
        this.walkable = false;
      } else {
        this.walkable = true;
      }

      this.spawn = params.Spawn || false;
      this.spawnTeam = params.SpawnTeam || 0;
      this.tileType = params.TileType || 'grass';
      this.castle = params.Castle || false;
      this.capturable = params.Capturable || false;
      this.blocksVision = (params.BlocksVision) || false;
      this.owner = params.Owner || 0;
      this.objective = params.Objective || null;
      if (params.Unit) {
        this.unit = params.Unit.Uid;
      }
      this.x = x / TILESIZE;
      this.y = y / TILESIZE;

      var self = this;

      this.distanceToTile = function(x, y) {
        return Math.abs(self.x - x) + Math.abs(self.y - y);
      }

      this.defenseModifier = function() {
        return self.defenseMod;
      }
      this.attackModifier = function() {
        return self.attackMod;
      }
      this.damageModifier = function() {
        return self.damageMod;
      }
      this.movementModifier = function() {
        if (!self.movementMod) return 1;
        return self.movementMod;
      }
    }


    var updateSelectedTile = function(newVal){
      console.log(newVal.event.code)

      switch (newVal.event.code) {
        case 'Digit1':
          selectedTile = 1;
          break;
        case 'Digit2':
          selectedTile = 2;
          break;
        case 'Digit3':
          if (selectedTile == 3) selectedTile = 7;
          else if (selectedTile == 7) selectedTile = 3;
          else selectedTile = 3;
          break;
        case 'Digit4':
          selectedTile = 4;
          break;
        case 'KeyQ':
          if (selectedTile == 5) selectedTile = 6;
          else if (selectedTile == 6) selectedTile = 8;
          else if (selectedTile == 8) selectedTile = 5;
          else selectedTile = 5;
          break;
        default:
          selectedTile = 1;
      }

      print(selectedTile);

    }

    function createMapArray(w, h){
      var tilesArray = new Array(w);
      for (var i = 0; i < w; i++) {
        tilesArray[i] = new Array(h);
        for (var k = 0; k < h; k++) {
          var key;
          if (k % 2 == 0) key = 'grass1';
          else key = 'grass1';
          tilesArray[i][k] = new MapTile(i * TILESIZE, k * TILESIZE, key);
        }
      }
      return tilesArray;
    }

    function clearMap() {
      game.world.removeAll();
      unitHash = {};
      var btn = document.getElementById('endturn');
      //btn.style.display = 'none';
    }

    function loadMap(mapAry){
      importTMX(JSON.parse(mapAry.Message));
    }

    function displayMainMenu(){
      clearMap();
      game.add.sprite(0, 0, 'mmbg');
      var playbtn = game.add.sprite(350, 450, 'playbutton');
      playbtn.events.onInputDown.add(function(){
        if (searching) {
          ws.send('exit_queue');
          playbtn.loadTexture('playbutton');
          searching = false;
        } else {
          armySelectModal();
        }
      });
      playbtn.inputEnabled = true;


      function armySelectModal() {
        if (!loggedIn) {
          return
        }

        var inputOptions = {};
        for (var i = 0; i < clientData.Armies.length; i++) {
          inputOptions[clientData.Armies[i].ID] = clientData.Armies[i].Name
        }
        swal({
        title: 'Select Your Army',
        input: 'select',
        inputOptions: inputOptions,
        inputPlaceholder: 'Army',
        showCancelButton: true,
        inputValidator: function(value) {
          return new Promise(function(resolve, reject) {
            if (value) {
              ws.send(JSON.stringify({MessageType: "find_game", Message: value}));
              resolve();
            } else {
              reject('You need to select a valid army.');
            }
          });
        }
        }).then(function(result) {
          playbtn.loadTexture('searchingbutton');
          searching = true;
        })
      }
    }

    function newMap() {
      clearMap();
      tileArray = createMapArray(26, 14);

    }

    function create() {
      //tileArray = createMapArray(30, 25);

      key1 = game.input.keyboard.addKey(Phaser.Keyboard.ONE);
      key1.onDown.add(updateSelectedTile, this);
      key2 = game.input.keyboard.addKey(Phaser.Keyboard.TWO);
      key2.onDown.add(updateSelectedTile, this);
      key3 = game.input.keyboard.addKey(Phaser.Keyboard.THREE);
      key3.onDown.add(updateSelectedTile, this);
      key4 = game.input.keyboard.addKey(Phaser.Keyboard.FOUR);
      key4.onDown.add(updateSelectedTile, this);

      keyE = game.input.keyboard.addKey(Phaser.Keyboard.E);
      keyE.onDown.add(exportMap, this);

      keyQ = game.input.keyboard.addKey(Phaser.Keyboard.Q);
      keyQ.onDown.add(updateSelectedTile, this);

      game.world.scale.set(1);
      game.camera.bounds = undefined;
      game.stage.disableVisibilityChange = true;

      displayMainMenu();
    }

    function getMapTileByIndex(index){
      var count = 0;
      for (var i = 0; i < tileArray[0].length; i++) {
        for (var j = 0; j < tileArray.length; j++) {
          if (count == index) { return tileArray[j][i]; }
          count = count + 1;
        }
      }
    }

    function importTMX(json){
      clearMap();
      tileArray = createMapArray(json.width, json.height);
      for (var i = 0; i < json.layers.length; i++) {
        for (var j = 0; j < json.layers[i].data.length; j++) {
          if (json.layers[i].data[j] != 0) {
            var t = getMapTileByIndex(j);
            var drawTile = true;
            if (json.layers[i].properties) {
              if (typeof(json.layers[i].properties.Walkable) != "undefined"){
                t.walkable = json.layers[i].properties.Walkable
              }
              if (json.layers[i].properties.Spawn) {
                t.spawn = json.layers[i].properties.Spawn;
                t.spawnTeam = json.layers[i].properties.SpawnTeam;
                drawTile = false;
              }
              if (json.layers[i].properties.MovementModifier) t.movementMod = json.layers[i].properties.MovementModifier;
              if (json.layers[i].properties.DefenseModifier) t.defenseMod = json.layers[i].properties.DefenseModifier;
              if (json.layers[i].properties.AttackModifier) t.attackMod = json.layers[i].properties.AttackModifier;
              if (json.layers[i].properties.DamageModifier) t.damageMod = json.layers[i].properties.DamageModifier;

              if (json.layers[i].properties.TileType) t.tileType = json.layers[i].properties.TileType ;
              if (json.layers[i].properties.BlocksVision) t.blocksVision = json.layers[i].properties.BlocksVision ;
              if (json.layers[i].properties.Objective){
                t.objective = {};
              }
            }
            if (drawTile) {
              var newSprite = game.add.sprite(t.x * TILESIZE, t.y * TILESIZE, 'terrain');
              newSprite.frame = json.layers[i].data[j] - 1;
              newSprite.events.onInputDown.add(function(e){
                if (inGame && selectedUnit && selectedUnit.team == myTeam && myTurn() && tileArray[e.x / TILESIZE][e.y / TILESIZE].walkable) {
                  selectedUnit.move(e.x / TILESIZE, e.y / TILESIZE);
                }
              });
              newSprite.inputEnabled = true;
            }
          }
        }
      }
    }

    window.importTMX = importTMX;

    function exportMap(){
      var ret = {};
      ret.message = {};
      ret.message.map = new Array(tileArray.length);
      for (var i = 0; i < tileArray.length; i++) {
        ret.message.map[i] = new Array(tileArray[0].length);
        for (var k = 0; k < tileArray[0].length; k++) {
          var tileJson = {};
          var tileObj = tileArray[i][k];
          tileJson.overlayKey = tileObj.overlayKey;
          tileJson.walkable = tileObj.walkable;
          tileJson.spawn = tileObj.spawn;
          tileJson.spawnTeam = tileObj.spawnTeam;
          tileJson.tileType = tileObj.tileType;
          tileJson.castle = tileObj.castle;
          tileJson.capturable = tileObj.capturable;
          tileJson.blocksVision = tileObj.blocksVision;
          tileJson.x = tileObj.x;
          tileJson.y = tileObj.y;
          ret.message.map[i][k] = tileJson;
        }
      }
      print("exporting map");
      console.log("EXPORTING");
      console.log(ret.message)
      //console.log(ret);
      ret.message = JSON.stringify(ret.message);
      ret.messageType = "map_export_data";
      ws.send(JSON.stringify(ret));
    }

    function update() {
      for (var i = 0; i < activeNotifications.length; i++) {
        activeNotifications[i].y -= 2;
        activeNotifications[i].alpha -= 0.025;
        if (activeNotifications[i].alpha <= 0) {
          activeNotifications[i].destroy();
          activeNotifications.splice(i, 1);
        }
      }
      if (activeMove.unit && activeMove.path) {
        if (activeMove.currentDest) {
          if (activeMove.unit.sprite.x < (activeMove.currentDest[0] * TILESIZE)) {
            activeMove.unit.sprite.x += 3;
          }
          if (activeMove.unit.sprite.x > (activeMove.currentDest[0] * TILESIZE)) {
            activeMove.unit.sprite.x -= 3;
          }

          if (activeMove.unit.sprite.y < (activeMove.currentDest[1] * TILESIZE)) {
            activeMove.unit.sprite.y += 3;
          }
          if (activeMove.unit.sprite.y > (activeMove.currentDest[1] * TILESIZE)) {
            activeMove.unit.sprite.y -= 3;
          }

          if (activeMove.unit.sprite.x == (activeMove.currentDest[0] * TILESIZE) && activeMove.unit.sprite.y == (activeMove.currentDest[1] * TILESIZE)){
            activeMove.currentIndex += 1;
            if (activeMove.path[activeMove.currentIndex]) activeMove.currentDest = activeMove.path[activeMove.currentIndex];
            else activeMove = {};
          }
        } else {
          activeMove.currentDest = activeMove.path[0];
          activeMove.currentIndex = 0;
          console.log("setting destination to " + activeMove.currentDest)
        }
      }
      if (game.input.activePointer.withinGame)
      {
          game.input.enabled = true;
          if (game.input.keyboard.isDown(Phaser.Keyboard.W)){
            game.camera.y -= 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.A)){
            game.camera.x -= 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.S)){
            game.camera.y += 5;
          }
          if (game.input.keyboard.isDown(Phaser.Keyboard.D)){
            game.camera.x += 5;
          }

          if (game.input.keyboard.isDown(Phaser.Keyboard.ESC)){
            if (lastMessage['default'] != "It is your turn." && lastMessage['default'] != "It is your opponents turn.") {
              DeselectRange();
              selectedUnit = null;
              cursor.x = -48;
              cursor.y = -48;
              if (myTurn()) print("It is your turn.");
              else print("It is your opponents turn.");
            }
          }
      }
      else
      {
          game.input.enabled = false;
      }


    }

  function makeBresenham(xStart, yStart, xEnd, yEnd) {
		var deltaX = Math.floor(Math.abs(xEnd - xStart));
		var deltaY = Math.floor(Math.abs(yEnd - yStart));
		var xStep = (xEnd >= xStart) ? 1 : -1;
		var yStep = (yEnd >= yStart) ? 1 : -1;
		var error = deltaX - deltaY;
		var xGrid = xStart, yGrid = yStart;

		function hasNext() {
			return !(xGrid == xEnd && yGrid == yEnd);
		}

		function next() {
			var toReturn = {x: xGrid, y: yGrid};

			var twoError = 2 * error;
			if (twoError > (-1 * deltaY)) {
				error -= deltaY;
				xGrid += xStep;
			}
			if (twoError < deltaX) {
				error += deltaX;
				yGrid += yStep;
			}

			return toReturn;
		}

		return {
			next: next,
			hasNext: hasNext
		};
	}

});
</script>
</head>
<body>
<p><input id="input" type="text" value="new">
<button id="send">Send</button>
<button id="endturn">End Turn</button>
<div id="weapons"></div>
<div id="game">
</div>
<div id="output"></div>
<div id="hud">
<img src="../client/assets/hud.png">
<div id="hud-output"></div>
<div id="stat-output"></div>
<div id="card-output"></div>
</img>
</div>
<div id="weapons-hud">
  <img src="../client/assets/weaponshud.png">
  <div id="weapons-output"></div>
  </img>
</div>
</body>
</html>
